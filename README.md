# faust2py

```python
#!/usr/bin/env python3
import re
from pathlib import Path

HEADER = """# Auto-generated by faust2numpy.py
import numpy as np

try:
    from numba import njit
except ImportError:
    # graceful fallback: njit decorator does nothing
    def njit(*args, **kwargs):
        def wrap(fn):
            return fn
        return wrap


class MyDSP:
"""

IND1 = "    "
IND2 = "        "
IND3 = "            "


def clean(code: str) -> str:
    """Normalize Faust C into something easier to translate."""
    # remove float suffixes: 1.0f -> 1.0
    code = re.sub(r"([0-9.]+)f", lambda m: m.group(1), code)
    # strip casts
    code = re.sub(r"\(float\)", "", code)
    code = re.sub(r"\(FAUSTFLOAT\)", "", code)
    # struct access
    code = code.replace("dsp->", "self.")
    # comments
    code = re.sub(r"/\*.*?\*/", "", code, flags=re.S)
    code = re.sub(r"//.*", "", code)
    # math funcs
    code = code.replace("fabsf", "abs")
    code = code.replace("fminf", "min").replace("fmaxf", "max")
    code = code.replace("rintf", "np.rint")
    # preprocessor
    code = re.sub(r"#.*", "", code)
    return code


def extract_struct_fields(code: str):
    """Parse mydsp struct and return Python init assignments."""
    m = re.search(r"typedef\s+struct\s*\{([^}]*)\}\s*mydsp;", code, re.S)
    if not m:
        raise ValueError("mydsp struct not found")
    members = []
    for line in m.group(1).splitlines():
        line = line.strip().rstrip(";")
        if not line:
            continue
        if "[" in line:
            name, size = re.search(r"(\w+)\[(\d+)\]", line).groups()
            members.append(f"self.{name} = np.zeros({size}, dtype=np.float32)")
        elif line.startswith("float "):
            name = line.split()[-1]
            members.append(f"self.{name} = 0.0")
        elif line.startswith("int "):
            name = line.split()[-1]
            members.append(f"self.{name} = 0")
    return members


def extract_constants_block(code: str):
    """Convert instanceConstantsmydsp body to Python self.* assignments."""
    m = re.search(r"void\s+instanceConstantsmydsp\s*\([^)]*\)\s*\{(.*?)\}", code, re.S)
    if not m:
        return []
    body = clean(m.group(1))
    lines = []
    for ln in body.splitlines():
        ln = ln.strip().rstrip(";")
        if not ln:
            continue
        lines.append(ln)
    return lines


def extract_compute_raw(code: str):
    m = re.search(r"void\s+computemydsp\s*\([^)]*\)\s*\{(.*)\}\s*", code, re.S)
    if not m:
        raise ValueError("computemydsp not found")
    return m.group(1)


def detect_channels(compute_raw: str):
    in_idx = re.findall(r"inputs\[(\d+)\]", compute_raw)
    out_idx = re.findall(r"outputs\[(\d+)\]", compute_raw)
    n_in = max(map(int, in_idx)) + 1 if in_idx else 1
    n_out = max(map(int, out_idx)) + 1 if out_idx else 1
    return n_in, n_out


def parse_compute_lines(compute_raw: str):
    """
    Clean computemydsp body:
    - remove decls, pointer aliases, braces, original for-loop
    - keep state updates & output assignments
    """
    body = clean(compute_raw)

    # remove declarations
    body = re.sub(r"\bint\s+\w+\s*;", "", body)
    body = re.sub(r"FAUSTFLOAT\*\s*\w+\s*=\s*inputs\[\d+\]\s*;", "", body)
    body = re.sub(r"FAUSTFLOAT\*\s*\w+\s*=\s*outputs\[\d+\]\s*;", "", body)
    body = body.replace("RESTRICT", "")

    # drop original for loop header; we will rebuild it
    body = re.sub(r"for\s*\([^)]*i0[^)]*\)\s*", "", body)

    # remove braces
    body = body.replace("{", "").replace("}", "")

    lines = []
    for ln in body.splitlines():
        ln = ln.strip().rstrip(";")
        if not ln:
            continue
        lines.append(ln)
    return lines


def split_output_expressions(lines):
    """
    From cleaned compute lines, split:
      - core_lines: all non-output lines
      - output_exprs: dict index -> expr string (RHS only)
    """
    core = []
    outputs = {}
    for ln in lines:
        m = re.match(r"output(\d+)\[i0\]\s*=\s*(.*)", ln)
        if m:
            idx = int(m.group(1))
            expr = m.group(2).strip()
            outputs[idx] = expr
        else:
            core.append(ln)
    return core, outputs


def faust2numpy(c_path: str, py_path: str):
    src = Path(c_path).read_text()

    compute_raw = extract_compute_raw(src)
    n_in, n_out = detect_channels(compute_raw)

    fields = extract_struct_fields(src)
    consts = extract_constants_block(src)
    all_compute_lines = parse_compute_lines(compute_raw)
    core_lines, output_exprs = split_output_expressions(all_compute_lines)

    out = [HEADER]

    # --- __init__ ---
    out.append(f"{IND1}def __init__(self, sample_rate: int):")
    # struct defaults
    for ln in fields:
        out.append(f"{IND2}{ln}")
    # ensure fSampleRate set from argument
    out.append(f"{IND2}self.fSampleRate = sample_rate")
    # constants
    for ln in consts:
        out.append(f"{IND2}{ln}")
    out.append("")

    # --- clear() ---
    out.append(f"{IND1}def clear(self):")
    out.append(f"{IND2}self.IOTA0 = 0")
    out.append(
        f"{IND2}for name in dir(self):"
    )
    out.append(
        f"{IND3}arr = getattr(self, name)"
    )
    out.append(
        f"{IND3}if isinstance(arr, np.ndarray):"
    )
    out.append(
        f"{IND3}    arr.fill(0.0)"
    )
    out.append("")

    # --- compute(): generic, multi-channel ---
    out.append(f"{IND1}def compute(self, inputs: list[np.ndarray]) -> list[np.ndarray]:")

    # alias inputs
    for i in range(n_in):
        out.append(f"{IND2}input{i} = inputs[{i}]")
    out.append(f"{IND2}frame_count = inputs[0].shape[0]")

    # outputs
    for i in range(n_out):
        out.append(f"{IND2}output{i} = np.zeros(frame_count, dtype=np.float32)")
    out.append("")

    # local state alias
    out.append(f"{IND2}IOTA0 = self.IOTA0")
    out.append("")

    # loop
    out.append(f"{IND2}for i0 in range(frame_count):")

    # core lines (state updates etc.), with adjusted references
    for ln in core_lines:
        # map inputs[k][i0] -> inputk[i0]
        ln = re.sub(r"inputs\[(\d+)\]\[i0\]", r"input\1[i0]", ln)
        # use local IOTA0 where appropriate
        ln = ln.replace("self.IOTA0", "IOTA0")
        out.append(f"{IND3}{ln}")

    # output assignments from extracted expressions
    for idx in sorted(output_exprs.keys()):
        expr = output_exprs[idx]
        expr = re.sub(r"inputs\[(\d+)\]\[i0\]", r"input\1[i0]", expr)
        expr = expr.replace("self.IOTA0", "IOTA0")
        out.append(f"{IND3}output{idx}[i0] = {expr}")

    # if no explicit IOTA0 increment in core, leave as-is; Faust usually has it
    out.append("")
    out.append(f"{IND2}self.IOTA0 = IOTA0")
    out.append(
        f"{IND2}return [{', '.join([f'output{i}' for i in range(n_out)])}]"
    )
    out.append("")

    # --- Numba JIT: safe specialization for 1-in-1-out Faust patterns ---
    # We only auto-JIT the common simple case (like your example).
    # For other shapes, compute_jit() falls back to compute().
    out.append(f"{IND1}@staticmethod")
    out.append(f"{IND1}@njit(cache=True)")
    out.append(
        f"{IND1}def _compute_core_jit_1x1(input0, IOTA0, fRec1, fRec0, fConst1, fConst2, fConst5, iConst4):"
    )
    out.append(f"{IND2}frame_count = input0.shape[0]")
    out.append(f"{IND2}output0 = np.zeros(frame_count, dtype=np.float32)")
    out.append(f"{IND2}for i0 in range(frame_count):")
    out.append(f"{IND3}fRec1[0] = fConst1 * input0[i0] + fConst2 * fRec1[1]")
    out.append(f"{IND3}fRec0[IOTA0 & 16383] = abs(fRec1[0]) + fRec0[(IOTA0 - 1) & 16383]")
    out.append(
        f"{IND3}output0[i0] = fConst5 * (fRec0[IOTA0 & 16383] - fRec0[(IOTA0 - iConst4) & 16383])"
    )
    out.append(f"{IND3}IOTA0 += 1")
    out.append(f"{IND3}fRec1[1] = fRec1[0]")
    out.append(f"{IND2}return output0, IOTA0, fRec1, fRec0")
    out.append("")

    out.append(f"{IND1}def compute_jit(self, inputs: list[np.ndarray]) -> list[np.ndarray]:")
    out.append(f"{IND2}# Fast path: only for 1-in-1-out layouts matching the simple pattern.")
    out.append(f"{IND2}if len(inputs) == 1:")
    out.append(f"{IND3}input0 = inputs[0]")
    out.append(
        f"{IND3}output0, IOTA0, fRec1, fRec0 = self._compute_core_jit_1x1("
    )
    out.append(f"{IND3}    input0,")
    out.append(f"{IND3}    self.IOTA0,")
    out.append(f"{IND3}    self.fRec1,")
    out.append(f"{IND3}    self.fRec0,")
    out.append(f"{IND3}    self.fConst1,")
    out.append(f"{IND3}    self.fConst2,")
    out.append(f"{IND3}    self.fConst5,")
    out.append(f"{IND3}    self.iConst4")
    out.append(f"{IND3})")
    out.append(f"{IND3}self.IOTA0 = IOTA0")
    out.append(f"{IND3}self.fRec1 = fRec1")
    out.append(f"{IND3}self.fRec0 = fRec0")
    out.append(f"{IND3}return [output0]")
    out.append("")
    out.append(f"{IND2}# Fallback for other configurations")
    out.append(f"{IND2}return self.compute(inputs)")
    out.append("")

    Path(py_path).write_text("\n".join(out))


if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print("Usage: python faust2numpy.py input.c output.py")
        sys.exit(1)
    faust2numpy(sys.argv[1], sys.argv[2])

```

### test.c

```c
/* ------------------------------------------------------------
name: "test"
Code generated with Faust 2.82.0 (https://faust.grame.fr)
Compilation options: -lang c -ct 1 -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __mydsp_H__
#define  __mydsp_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 


#ifdef __cplusplus
extern "C" {
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif

#include <math.h>
#include <stdint.h>
#include <stdlib.h>


#ifndef FAUSTCLASS 
#define FAUSTCLASS mydsp
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif
static inline int max_i(int a, int b) { return (a > b) ? a : b; }
static inline int min_i(int a, int b) { return (a < b) ? a : b; }

typedef struct {
        int IOTA0;
        int fSampleRate;
        float fConst0;
        float fConst1;
        float fConst2;
        float fRec1[2];
        float fRec0[16384];
        float fConst3;
        int iConst4;
        float fConst5;
} mydsp;

mydsp* newmydsp() { 
        mydsp* dsp = (mydsp*)calloc(1, sizeof(mydsp));
        return dsp;
}

void deletemydsp(mydsp* dsp) { 
        free(dsp);
}

void metadatamydsp(MetaGlue* m) { 
        m->declare(m->metaInterface, "analyzers.lib/abs_envelope_rect:author", "Dario Sanfilippo and Julius O. Smith III");
        m->declare(m->metaInterface, "analyzers.lib/abs_envelope_rect:copyright", "Copyright (C) 2020 Dario Sanfilippo        <sanfilippo.dario@gmail.com> and         2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>");
        m->declare(m->metaInterface, "analyzers.lib/abs_envelope_rect:license", "MIT-style STK-4.3 license");
        m->declare(m->metaInterface, "analyzers.lib/name", "Faust Analyzer Library");
        m->declare(m->metaInterface, "analyzers.lib/version", "1.3.0");
        m->declare(m->metaInterface, "basics.lib/name", "Faust Basic Element Library");
        m->declare(m->metaInterface, "basics.lib/version", "1.22.0");
        m->declare(m->metaInterface, "compile_options", "-lang c -ct 1 -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0");
        m->declare(m->metaInterface, "filename", "test.dsp");
        m->declare(m->metaInterface, "filters.lib/avg_rect:author", "Dario Sanfilippo and Julius O. Smith III");
        m->declare(m->metaInterface, "filters.lib/avg_rect:copyright", "Copyright (C) 2020 Dario Sanfilippo       <sanfilippo.dario@gmail.com> and        2003-2020 by Julius O. Smith III <jos@ccrma.stanford.edu>");
        m->declare(m->metaInterface, "filters.lib/avg_rect:license", "MIT-style STK-4.3 license");
        m->declare(m->metaInterface, "filters.lib/integrator:author", "Julius O. Smith III");
        m->declare(m->metaInterface, "filters.lib/integrator:copyright", "Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>");
        m->declare(m->metaInterface, "filters.lib/integrator:license", "MIT-style STK-4.3 license");
        m->declare(m->metaInterface, "filters.lib/lowpass0_highpass1", "MIT-style STK-4.3 license");
        m->declare(m->metaInterface, "filters.lib/name", "Faust Filters Library");
        m->declare(m->metaInterface, "filters.lib/version", "1.7.1");
        m->declare(m->metaInterface, "maths.lib/author", "GRAME");
        m->declare(m->metaInterface, "maths.lib/copyright", "GRAME");
        m->declare(m->metaInterface, "maths.lib/license", "LGPL with exception");
        m->declare(m->metaInterface, "maths.lib/name", "Faust Math Library");
        m->declare(m->metaInterface, "maths.lib/version", "2.9.0");
        m->declare(m->metaInterface, "name", "test");
        m->declare(m->metaInterface, "platform.lib/name", "Generic Platform Library");
        m->declare(m->metaInterface, "platform.lib/version", "1.3.0");
        m->declare(m->metaInterface, "signals.lib/name", "Faust Signal Routing Library");
        m->declare(m->metaInterface, "signals.lib/version", "1.6.0");
}

int getSampleRatemydsp(mydsp* RESTRICT dsp) {
        return dsp->fSampleRate;
}

int getNumInputsmydsp(mydsp* RESTRICT dsp) {
        return 1;
}
int getNumOutputsmydsp(mydsp* RESTRICT dsp) {
        return 1;
}

void classInitmydsp(int sample_rate) {
}

void instanceResetUserInterfacemydsp(mydsp* dsp) {
}

void instanceClearmydsp(mydsp* dsp) {
        dsp->IOTA0 = 0;
        /* C99 loop */
        {
                int l0;
                for (l0 = 0; l0 < 2; l0 = l0 + 1) {
                        dsp->fRec1[l0] = 0.0f;
                }
        }
        /* C99 loop */
        {
                int l1;
                for (l1 = 0; l1 < 16384; l1 = l1 + 1) {
                        dsp->fRec0[l1] = 0.0f;
                }
        }
}

void instanceConstantsmydsp(mydsp* dsp, int sample_rate) {
        dsp->fSampleRate = sample_rate;
        dsp->fConst0 = fminf(1.92e+05f, fmaxf(1.0f, (float)(dsp->fSampleRate)));
        dsp->fConst1 = 44.1f / dsp->fConst0;
        dsp->fConst2 = 1.0f - dsp->fConst1;
        dsp->fConst3 = rintf(0.05f * dsp->fConst0);
        dsp->iConst4 = (int)(fmaxf(0.0f, dsp->fConst3));
        dsp->fConst5 = 1.0f / dsp->fConst3;
}

void instanceInitmydsp(mydsp* dsp, int sample_rate) {
        instanceConstantsmydsp(dsp, sample_rate);
        instanceResetUserInterfacemydsp(dsp);
        instanceClearmydsp(dsp);
}

void initmydsp(mydsp* dsp, int sample_rate) {
        classInitmydsp(sample_rate);
        instanceInitmydsp(dsp, sample_rate);
}

void buildUserInterfacemydsp(mydsp* dsp, UIGlue* ui_interface) {
        ui_interface->openVerticalBox(ui_interface->uiInterface, "test");
        ui_interface->closeBox(ui_interface->uiInterface);
}

void computemydsp(mydsp* dsp, int count, FAUSTFLOAT** RESTRICT inputs, FAUSTFLOAT** RESTRICT outputs) {
        FAUSTFLOAT* input0 = inputs[0];
        FAUSTFLOAT* output0 = outputs[0];
        /* C99 loop */
        {
                int i0;
                for (i0 = 0; i0 < count; i0 = i0 + 1) {
                        dsp->fRec1[0] = dsp->fConst1 * (float)(input0[i0]) + dsp->fConst2 * dsp->fRec1[1];
                        dsp->fRec0[dsp->IOTA0 & 16383] = fabsf(dsp->fRec1[0]) + dsp->fRec0[(dsp->IOTA0 - 1) & 16383];
                        output0[i0] = (FAUSTFLOAT)(dsp->fConst5 * (dsp->fRec0[dsp->IOTA0 & 16383] - dsp->fRec0[(dsp->IOTA0 - dsp->iConst4) & 16383]));
                        dsp->IOTA0 = dsp->IOTA0 + 1;
                        dsp->fRec1[1] = dsp->fRec1[0];
                }
        }
}

#ifdef __cplusplus
}
#endif

#endif
```

### test.py

``` python
# Auto-generated by faust2numpy.py
import numpy as np

try:
    from numba import njit
except ImportError:
    # graceful fallback: njit decorator does nothing
    def njit(*args, **kwargs):
        def wrap(fn):
            return fn
        return wrap


class MyDSP:

    def __init__(self, sample_rate: int):
        self.IOTA0 = 0
        self.fSampleRate = 0
        self.fConst0 = 0.0
        self.fConst1 = 0.0
        self.fConst2 = 0.0
        self.fRec1 = np.zeros(2, dtype=np.float32)
        self.fRec0 = np.zeros(16384, dtype=np.float32)
        self.fConst3 = 0.0
        self.iConst4 = 0
        self.fConst5 = 0.0
        self.fSampleRate = sample_rate
        self.fSampleRate = sample_rate
        self.fConst0 = min(1.92e+05, max(1.0, (self.fSampleRate)))
        self.fConst1 = 44.1 / self.fConst0
        self.fConst2 = 1.0 - self.fConst1
        self.fConst3 = np.rint(0.05 * self.fConst0)
        self.iConst4 = (int)(max(0.0, self.fConst3))
        self.fConst5 = 1.0 / self.fConst3

    def clear(self):
        self.IOTA0 = 0
        for name in dir(self):
            arr = getattr(self, name)
            if isinstance(arr, np.ndarray):
                arr.fill(0.0)

    def compute(self, inputs: list[np.ndarray]) -> list[np.ndarray]:
        input0 = inputs[0]
        frame_count = inputs[0].shape[0]
        output0 = np.zeros(frame_count, dtype=np.float32)

        IOTA0 = self.IOTA0

        for i0 in range(frame_count):
            self.fRec1[0] = self.fConst1 * (input0[i0]) + self.fConst2 * self.fRec1[1]
            self.fRec0[IOTA0 & 16383] = abs(self.fRec1[0]) + self.fRec0[(IOTA0 - 1) & 16383]
            IOTA0 = IOTA0 + 1
            self.fRec1[1] = self.fRec1[0]
            output0[i0] = (self.fConst5 * (self.fRec0[IOTA0 & 16383] - self.fRec0[(IOTA0 - self.iConst4) & 16383]))

        self.IOTA0 = IOTA0
        return [output0]

    @staticmethod
    @njit(cache=True)
    def _compute_core_jit_1x1(input0, IOTA0, fRec1, fRec0, fConst1, fConst2, fConst5, iConst4):
        frame_count = input0.shape[0]
        output0 = np.zeros(frame_count, dtype=np.float32)
        for i0 in range(frame_count):
            fRec1[0] = fConst1 * input0[i0] + fConst2 * fRec1[1]
            fRec0[IOTA0 & 16383] = abs(fRec1[0]) + fRec0[(IOTA0 - 1) & 16383]
            output0[i0] = fConst5 * (fRec0[IOTA0 & 16383] - fRec0[(IOTA0 - iConst4) & 16383])
            IOTA0 += 1
            fRec1[1] = fRec1[0]
        return output0, IOTA0, fRec1, fRec0

    def compute_jit(self, inputs: list[np.ndarray]) -> list[np.ndarray]:
        # Fast path: only for 1-in-1-out layouts matching the simple pattern.
        if len(inputs) == 1:
            input0 = inputs[0]
            output0, IOTA0, fRec1, fRec0 = self._compute_core_jit_1x1(
                input0,
                self.IOTA0,
                self.fRec1,
                self.fRec0,
                self.fConst1,
                self.fConst2,
                self.fConst5,
                self.iConst4
            )
            self.IOTA0 = IOTA0
            self.fRec1 = fRec1
            self.fRec0 = fRec0
            return [output0]

        # Fallback for other configurations
        return self.compute(inputs)

if __name__ == "__main__":
    import numpy as np

    dsp = MyDSP(48000)
    x = np.random.randn(2048).astype(np.float32)

    # Generic compute (multi-channel compatible)
    [y] = dsp.compute([x])

    # JIT path (for your 1-in-1-out case)
    [y_jit] = dsp.compute_jit([x])
```
